<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FCam: FCam::TSQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespace_f_cam.html">FCam</a>      </li>
      <li><a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue&lt; T &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>FCam::TSQueue&lt; T &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="FCam::TSQueue" -->
<p>Basic thread-safe consumer/producer queue.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>&gt;</code></p>

<p><a href="class_f_cam_1_1_t_s_queue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#aecc4eae7cffe7563580cc854423928da">push</a> (const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a copy of item to the back of the queue.  <a href="#aecc4eae7cffe7563580cc854423928da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#a3b27e9499d5e56ea7f4eef877840bace">pop</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the frontmost element from the queue.  <a href="#a3b27e9499d5e56ea7f4eef877840bace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#ac76c5841490b8d461f86f09102b7f94b">pushFront</a> (const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a copy of item to the front of the queue.  <a href="#ac76c5841490b8d461f86f09102b7f94b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#a1c2ce0333d3ff7fdec14e428edff3ed7">popBack</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the backmost element from the queue.  <a href="#a1c2ce0333d3ff7fdec14e428edff3ed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#a3d7fa3b9742c293dd0ba042b2c04fb45">front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the frontmost element of the queue.  <a href="#a3d7fa3b9742c293dd0ba042b2c04fb45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#a4a725e0565954b2d380390fad6f23256">back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the backmost element of the queue.  <a href="#a4a725e0565954b2d380390fad6f23256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#adf0328818d5393871f9e475dcecd5e00">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if empty, false otherwise.  <a href="#adf0328818d5393871f9e475dcecd5e00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af997ed193ec2ba116e21f1cf7cc8decf"></a><!-- doxytag: member="FCam::TSQueue::size" ref="af997ed193ec2ba116e21f1cf7cc8decf" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#af997ed193ec2ba116e21f1cf7cc8decf">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of items in the queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#af19f1e30abc87238159c0f950f223063">wait</a> (unsigned int timeout=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until there are entries in the queue.  <a href="#af19f1e30abc87238159c0f950f223063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#aa9c915a1e5daa518c0292ad5c9625fa3">pull</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for the queue not to be empty, and then copies the frontmost item, then pops it from the queue and returns the element copy.  <a href="#aa9c915a1e5daa518c0292ad5c9625fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#adb8e163cb972b38d1c1d7f7a236dc692">pullBack</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pulls the backmost element off the queue.  <a href="#adb8e163cb972b38d1c1d7f7a236dc692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#ab71f5f493aa82728d7dad93e154efb67">tryPull</a> (T *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically either dequeue an item, or fail to do so.  <a href="#ab71f5f493aa82728d7dad93e154efb67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">locking_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#a821b0ac953e5a93ac5a5764208cd298a">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an iterator referring to the front of the queue and locks the queue.  <a href="#a821b0ac953e5a93ac5a5764208cd298a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">locking_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#a2cd35517fee789e1a566ccee14cbbed9">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an iterator referring to the end of the queue and locks the queue.  <a href="#a2cd35517fee789e1a566ccee14cbbed9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_t_s_queue.html#ad19f9c46ca74b1c843b4c69b0890136a">erase</a> (<a class="el" href="class_f_cam_1_1_t_s_queue.html">TSQueue</a>&lt; T &gt;::locking_iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an entry referred to by a locking_iterator.  <a href="#ad19f9c46ca74b1c843b4c69b0890136a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br/>
 class FCam::TSQueue&lt; T &gt;</h3>

<p>Basic thread-safe consumer/producer queue. </p>
<p>Safe for multiple producers, but not for multiple consumers. The consumer will typically call <a class="el" href="class_f_cam_1_1_t_s_queue.html#af19f1e30abc87238159c0f950f223063" title="Waits until there are entries in the queue.">wait()</a>, <a class="el" href="class_f_cam_1_1_t_s_queue.html#a3b27e9499d5e56ea7f4eef877840bace" title="Remove the frontmost element from the queue.">pop()</a>, <a class="el" href="class_f_cam_1_1_t_s_queue.html#a3d7fa3b9742c293dd0ba042b2c04fb45" title="Return a reference to the frontmost element of the queue.">front()</a>, and pull, while producers mostly uses <a class="el" href="class_f_cam_1_1_t_s_queue.html#aecc4eae7cffe7563580cc854423928da" title="Add a copy of item to the back of the queue.">push()</a>. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00033">33</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aecc4eae7cffe7563580cc854423928da"></a><!-- doxytag: member="FCam::TSQueue::push" ref="aecc4eae7cffe7563580cc854423928da" args="(const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a copy of item to the back of the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00205">205</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b27e9499d5e56ea7f4eef877840bace"></a><!-- doxytag: member="FCam::TSQueue::pop" ref="a3b27e9499d5e56ea7f4eef877840bace" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the frontmost element from the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00222">222</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac76c5841490b8d461f86f09102b7f94b"></a><!-- doxytag: member="FCam::TSQueue::pushFront" ref="ac76c5841490b8d461f86f09102b7f94b" args="(const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::pushFront </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a copy of item to the front of the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00214">214</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c2ce0333d3ff7fdec14e428edff3ed7"></a><!-- doxytag: member="FCam::TSQueue::popBack" ref="a1c2ce0333d3ff7fdec14e428edff3ed7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::popBack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the backmost element from the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00231">231</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d7fa3b9742c293dd0ba042b2c04fb45"></a><!-- doxytag: member="FCam::TSQueue::front" ref="a3d7fa3b9742c293dd0ba042b2c04fb45" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the frontmost element of the queue. </p>
<p>Behavior not defined if <a class="el" href="class_f_cam_1_1_t_s_queue.html#af997ed193ec2ba116e21f1cf7cc8decf" title="Returns the number of items in the queue.">size()</a> == 0 </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00240">240</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4a725e0565954b2d380390fad6f23256"></a><!-- doxytag: member="FCam::TSQueue::back" ref="a4a725e0565954b2d380390fad6f23256" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the backmost element of the queue. </p>
<p>Behavior not defined if <a class="el" href="class_f_cam_1_1_t_s_queue.html#af997ed193ec2ba116e21f1cf7cc8decf" title="Returns the number of items in the queue.">size()</a> == 0 </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00257">257</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf0328818d5393871f9e475dcecd5e00"></a><!-- doxytag: member="FCam::TSQueue::empty" ref="adf0328818d5393871f9e475dcecd5e00" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if empty, false otherwise. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00275">275</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="af19f1e30abc87238159c0f950f223063"></a><!-- doxytag: member="FCam::TSQueue::wait" ref="af19f1e30abc87238159c0f950f223063" args="(unsigned int timeout=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits until there are entries in the queue. </p>
<p>The optional timeout is in microseconds, zero means no timeout. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00293">293</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9c915a1e5daa518c0292ad5c9625fa3"></a><!-- doxytag: member="FCam::TSQueue::pull" ref="aa9c915a1e5daa518c0292ad5c9625fa3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::pull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for the queue not to be empty, and then copies the frontmost item, then pops it from the queue and returns the element copy. </p>
<p>A convenience function, which is somewhat inefficient if T is a large class (so use it on pointer-containing queues, mostly). This is the only safe way for multiple consumers to use the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00331">331</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="adb8e163cb972b38d1c1d7f7a236dc692"></a><!-- doxytag: member="FCam::TSQueue::pullBack" ref="adb8e163cb972b38d1c1d7f7a236dc692" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::pullBack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pulls the backmost element off the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00343">343</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab71f5f493aa82728d7dad93e154efb67"></a><!-- doxytag: member="FCam::TSQueue::tryPull" ref="ab71f5f493aa82728d7dad93e154efb67" args="(T *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::tryPull </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically either dequeue an item, or fail to do so. </p>
<p>Does not block. Returns whether it succeeded. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00353">353</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a821b0ac953e5a93ac5a5764208cd298a"></a><!-- doxytag: member="FCam::TSQueue::begin" ref="a821b0ac953e5a93ac5a5764208cd298a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_cam_1_1_t_s_queue.html">TSQueue</a>&lt; T &gt;::locking_iterator <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an iterator referring to the front of the queue and locks the queue. </p>
<p>Queue will remain locked until all the locked_iterators referring to it are destroyed. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00375">375</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2cd35517fee789e1a566ccee14cbbed9"></a><!-- doxytag: member="FCam::TSQueue::end" ref="a2cd35517fee789e1a566ccee14cbbed9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_cam_1_1_t_s_queue.html">TSQueue</a>&lt; T &gt;::locking_iterator <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an iterator referring to the end of the queue and locks the queue. </p>
<p>Queue will remain locked until all the iterators referring to it are destroyed. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00380">380</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad19f9c46ca74b1c843b4c69b0890136a"></a><!-- doxytag: member="FCam::TSQueue::erase" ref="ad19f9c46ca74b1c843b4c69b0890136a" args="(TSQueue&lt; T &gt;::locking_iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_cam_1_1_t_s_queue.html">FCam::TSQueue</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_cam_1_1_t_s_queue.html">TSQueue</a>&lt; T &gt;::locking_iterator&nbsp;</td>
          <td class="paramname"> <em>li</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes an entry referred to by a locking_iterator. </p>
<p>Like a standard deque, if the entry erased is at the start or end of the queue, other iterators remain valid. Otherwise, all iterators and references are invalidated. Returns true if entry is successfully deleted. Failure can occur if some other thread(s) successfully reserved a queue entry/entries before the locking iterator claimed the queue. </p>

<p>Definition at line <a class="el" href="_t_s_queue_8h_source.html#l00385">385</a> of file <a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/FCam/<a class="el" href="_t_s_queue_8h_source.html">TSQueue.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Nov 12 2010 15:26:14 for FCam by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
