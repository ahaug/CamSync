<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FCam: FCam::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespace_f_cam.html">FCam</a>      </li>
      <li><a class="el" href="class_f_cam_1_1_image.html">FCam::Image</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>FCam::Image Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="FCam::Image" -->
<p>A reference-counted <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> object.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_image_8h_source.html">Image.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for FCam::Image:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_cam_1_1_image__coll__graph.png" border="0" usemap="#_f_cam_1_1_image_coll__map" alt="Collaboration graph"/></div>
<map name="_f_cam_1_1_image_coll__map" id="_f_cam_1_1_image_coll__map">
<area shape="rect" id="node2" href="struct_f_cam_1_1_size.html" title="A class to represent sizes of two dimensional objects like images." alt="" coords="9,5,100,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_f_cam_1_1_image-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Image property accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcd78bd8c65cd97e8adba4eb42bd284b6"></a>These methods return values of the various <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> properties, which are immutable for a given <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> instance. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_cam_1_1_size.html">Size</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a7d37cd8a3e0d126b031e152898aa4369">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the image in pixels.  <a href="#a7d37cd8a3e0d126b031e152898aa4369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#ac44569fe5a9f3843cf75b8b6edb07e80">width</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The width of the image in pixels.  <a href="#ac44569fe5a9f3843cf75b8b6edb07e80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a278b601ba0a86e6da0291659e0db054e">height</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The height of the image in pixels.  <a href="#a278b601ba0a86e6da0291659e0db054e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dd7bb72d37747a5293f575a51b48445"></a><!-- doxytag: member="FCam::Image::type" ref="a2dd7bb72d37747a5293f575a51b48445" args="() const " -->
<a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a2dd7bb72d37747a5293f575a51b48445">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The format of the image data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a0173d44875d7c65967e600e6ee50b59f">bytesPerPixel</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of an image pixel in bytes.  <a href="#a0173d44875d7c65967e600e6ee50b59f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#add66fb78d4a26c308e591d9b84912de8">bytesPerRow</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The increment between two rows of the image in bytes.  <a href="#add66fb78d4a26c308e591d9b84912de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e095a9e7aa019fea6a0ba208e665fc1"></a><!-- doxytag: member="FCam::Image::valid" ref="a2e095a9e7aa019fea6a0ba208e665fc1" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a2e095a9e7aa019fea6a0ba208e665fc1">valid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if it's safe to access the image data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#aab16a298c1df4a4a79ec9b11e95a5bf2">discard</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this image is a special Discard image.  <a href="#aab16a298c1df4a4a79ec9b11e95a5bf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a3211402f34df40097f0412dd343d1fcc">autoAllocate</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this image is a special AutoAllocate image.  <a href="#a3211402f34df40097f0412dd343d1fcc"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Allocating Constructors and Factory Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2de6bb07f091901f9035ce036d0e75a1"></a>These image constructors allocate new memory for image data.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a3321135f81f8dc9a2ba65009d6202116">Image</a> (<a class="el" href="struct_f_cam_1_1_size.html">Size</a>, <a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new image of the given size in the given format.  <a href="#a3321135f81f8dc9a2ba65009d6202116"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a9b0418982ec32bff289c9a5937eb4d7f">Image</a> (int, int, <a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new image of the given size in the given format.  <a href="#a9b0418982ec32bff289c9a5937eb4d7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a25960a51465e9b833a2ac56746cc5787">Image</a> (int fd, int offset, <a class="el" href="struct_f_cam_1_1_size.html">Size</a>, <a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>, bool writeThrough=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use memory mapped I/O to construct an image from a buffer stored in a file.  <a href="#a25960a51465e9b833a2ac56746cc5787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_cam_1_1_image.html">Image</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a3cf193eeb6fcb23dc51137a494f5b2da">copy</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> containing a copy of the current Image's data.  <a href="#a3cf193eeb6fcb23dc51137a494f5b2da"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Non-allocating Constructors and Factory Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9127ce9b2f40710444ad6d302ca85742"></a>These image constructors make a new reference to already existing image data.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a3b5e7dfc432e572235174019c4fa29e7">Image</a> (<a class="el" href="struct_f_cam_1_1_size.html">Size</a>, <a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>, unsigned char *, int srcBytesPerRow=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new image of the given size in the given format using already existing data.  <a href="#a3b5e7dfc432e572235174019c4fa29e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a4e3031384b05035ab7b896faf8e60e4d">Image</a> (int, int, <a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>, unsigned char *, int srcBytesPerRow=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new image of the given size in the given format using already existing data.  <a href="#a4e3031384b05035ab7b896faf8e60e4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f78856f9ae33ee5070ffaeb65b27801"></a><!-- doxytag: member="FCam::Image::Image" ref="a2f78856f9ae33ee5070ffaeb65b27801" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a2f78856f9ae33ee5070ffaeb65b27801">Image</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new image with no memory allocated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a18812f15144ca7c54368a2352f175d5e">Image</a> (const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of the image reference.  <a href="#a18812f15144ca7c54368a2352f175d5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_cam_1_1_image.html">Image</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a8e80f78c2522d748e91952bc91ebd420">subImage</a> (unsigned int x, unsigned int y, <a class="el" href="struct_f_cam_1_1_size.html">Size</a>) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retuns an image that points to a section of the current image.  <a href="#a8e80f78c2522d748e91952bc91ebd420"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#ab49efc2d6383c57fb67f34182f3e7afe">operator=</a> (const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Become a new reference to an existing image.  <a href="#ab49efc2d6383c57fb67f34182f3e7afe"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Image data accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8c33c01cdf26fb2c0b66e130c081a62a"></a>These methods allow you to change the pixel data referenced by the <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a>. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#aef8822e9506f3419cf96862764588c85">operator()</a> (unsigned int x, unsigned int y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a pixel in the image.  <a href="#aef8822e9506f3419cf96862764588c85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#ac01a574c3466aa4a0b93cdb8cacfee5d">copyFrom</a> (const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the image data from the source <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> into this <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a>.  <a href="#ac01a574c3466aa4a0b93cdb8cacfee5d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp1f59a20e05c8d04770a9c1bf93593cfa"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a78791c1f2da4e9ef0093cbf25c3b01e9">lock</a> (int timeout=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the image to prevent other threads writing to it with a configurable timeout in microseconds.  <a href="#a78791c1f2da4e9ef0093cbf25c3b01e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a98de7193d8d8c41c844f1576e6b1e703">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the image.  <a href="#a98de7193d8d8c41c844f1576e6b1e703"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#acb02eaaf88304c70258b0ce17a4915b6">operator==</a> (const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two images for equality.  <a href="#acb02eaaf88304c70258b0ce17a4915b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c86840a1a924ba04f44e658f8ef2c16"></a><!-- doxytag: member="FCam::Image::debug" ref="a1c86840a1a924ba04f44e658f8ef2c16" args="(const char *name=&quot;&quot;) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a1c86840a1a924ba04f44e658f8ef2c16">debug</a> (const char *name=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out some debugging info about the image, optionally taking in a name to identify the image. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#a5d22d34434fe7c747f902ce4e645f6ee">Discard</a> = (unsigned char *)(0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This value for data represents an image with no allocated memory that should never have data copied into it.  <a href="#a5d22d34434fe7c747f902ce4e645f6ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_cam_1_1_image.html#afb3e57a2a829d8cd8aeec326ca8e1c84">AutoAllocate</a> = (unsigned char *)(-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This value for data represents image data whose first user should allocate memory for.  <a href="#afb3e57a2a829d8cd8aeec326ca8e1c84"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A reference-counted <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> object. </p>
<p>Images are stored in row-major order, with the origin is the top left corner of the image. While each scanline is guaranteed to be consecutive in memory, there may be padding in between adjacent scanlines.</p>
<p>If you instantiate an image using one of the constructors that allocates data, the result will be a reference counted image object, that automatically deletes the data when the last reference to it is destroyed.</p>
<p>If you use a constructor that sets the data field, you're telling the image class that someone else is managing that memory, and the destructor will never be called.</p>
<p>Either way, you can safely pass <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> objects by value without incurring the cost of memory copies. Only the explicit <code>copy</code> methods will copy the underlying image data. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00034">34</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3321135f81f8dc9a2ba65009d6202116"></a><!-- doxytag: member="FCam::Image::Image" ref="a3321135f81f8dc9a2ba65009d6202116" args="(Size, ImageFormat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FCam::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_cam_1_1_size.html">Size</a>&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new image of the given size in the given format. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00041">41</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b0418982ec32bff289c9a5937eb4d7f"></a><!-- doxytag: member="FCam::Image::Image" ref="a9b0418982ec32bff289c9a5937eb4d7f" args="(int, int, ImageFormat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FCam::Image::Image </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new image of the given size in the given format. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00023">23</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25960a51465e9b833a2ac56746cc5787"></a><!-- doxytag: member="FCam::Image::Image" ref="a25960a51465e9b833a2ac56746cc5787" args="(int fd, int offset, Size, ImageFormat, bool writeThrough=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FCam::Image::Image </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_cam_1_1_size.html">Size</a>&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeThrough</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use memory mapped I/O to construct an image from a buffer stored in a file. </p>
<p>The image will therefore be paged out as needed, and if the optional parameter is set to true, modifying the image data will also modify the image on disk. Note that the file descriptor passed to this constructor can be closed after the <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> is constructed with no problems, and the file can even be deleted - in that case, the file will not actually be erased until the last <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> referring to the buffer is destroyed. The arguments are the file description of the file, the number of bytes into the file the image buffer starts at, and the dimensions and format of the image, followed by whether changing the image data also changes the file. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00059">59</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b5e7dfc432e572235174019c4fa29e7"></a><!-- doxytag: member="FCam::Image::Image" ref="a3b5e7dfc432e572235174019c4fa29e7" args="(Size, ImageFormat, unsigned char *, int srcBytesPerRow=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FCam::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_cam_1_1_size.html">Size</a>&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcBytesPerRow</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new image of the given size in the given format using already existing data. </p>
<p>The image will never deallocate this data. This is a good way to cast some other image type to FCam's image type without allocating new data or copying image data. These constructors optionally take in the number of bytes per row of image data, to allow for Images that contain a subset of the source data, or for source data with padding. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00131">131</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e3031384b05035ab7b896faf8e60e4d"></a><!-- doxytag: member="FCam::Image::Image" ref="a4e3031384b05035ab7b896faf8e60e4d" args="(int, int, ImageFormat, unsigned char *, int srcBytesPerRow=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FCam::Image::Image </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_cam.html#a677071e67e8ff9e73ea32ce2e5b59559">ImageFormat</a>&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcBytesPerRow</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new image of the given size in the given format using already existing data. </p>
<p>The image will never deallocate this data. This is a good way to cast some other image type to FCam's image type without allocating new data or copying image data. These constructors optionally take in the number of bytes per row of image data, to allow for Images that contain a subset of the source data, or for source data with padding. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00151">151</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18812f15144ca7c54368a2352f175d5e"></a><!-- doxytag: member="FCam::Image::Image" ref="a18812f15144ca7c54368a2352f175d5e" args="(const Image &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FCam::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a copy of the image reference. </p>
<p>Doesn't copy image data, just produces a new reference to the same data. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00175">175</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7d37cd8a3e0d126b031e152898aa4369"></a><!-- doxytag: member="FCam::Image::size" ref="a7d37cd8a3e0d126b031e152898aa4369" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_cam_1_1_size.html">Size</a> FCam::Image::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size of the image in pixels. </p>
<p>Note: The image size in memory is not necessarily equal to <code>size.width*size</code>.height*bytesPerPixel, since <em>bytesPerRow</em> may be larger than <code>size.width*bytesPerPixel</code> if dealing with aligned images or subimages. The true image memory extent is <code>size.height*bytesPerRow</code>. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00051">51</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac44569fe5a9f3843cf75b8b6edb07e80"></a><!-- doxytag: member="FCam::Image::width" ref="ac44569fe5a9f3843cf75b8b6edb07e80" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FCam::Image::width </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The width of the image in pixels. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00056">56</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a278b601ba0a86e6da0291659e0db054e"></a><!-- doxytag: member="FCam::Image::height" ref="a278b601ba0a86e6da0291659e0db054e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FCam::Image::height </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The height of the image in pixels. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00061">61</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0173d44875d7c65967e600e6ee50b59f"></a><!-- doxytag: member="FCam::Image::bytesPerPixel" ref="a0173d44875d7c65967e600e6ee50b59f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FCam::Image::bytesPerPixel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size of an image pixel in bytes. </p>
<p>This is strictly equal to <em><a class="el" href="namespace_f_cam.html#aee1005dd1587f08eccd6af2e955c2dde" title="How many bytes per pixel are used by a given format.">FCam::bytesPerPixel</a></em>(<a class="el" href="class_f_cam_1_1_image.html#a2dd7bb72d37747a5293f575a51b48445" title="The format of the image data.">type()</a>), and is cached here for convenience </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00076">76</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="add66fb78d4a26c308e591d9b84912de8"></a><!-- doxytag: member="FCam::Image::bytesPerRow" ref="add66fb78d4a26c308e591d9b84912de8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FCam::Image::bytesPerRow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The increment between two rows of the image in bytes. </p>
<p>This is the number of bytes you have to increment by to move from one row to the next. That is, pixel <code></code>(x,y) is located at memory location <code>data+y*bytesPerRow+x*bytesPerPixel</code>. <em>bytesPerRow</em> is at least equal to <code>size.width*bytesPerPixel</code>, but may be larger for a subimage (an image that's only a region of a larger source image), or an image that has rows aligned in memory for faster access. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00091">91</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab16a298c1df4a4a79ec9b11e95a5bf2"></a><!-- doxytag: member="FCam::Image::discard" ref="aab16a298c1df4a4a79ec9b11e95a5bf2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FCam::Image::discard </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this image is a special Discard image. </p>
<p>When passed as an argument to a function, a Discard image indicates that the function should not produce any image output, but should perform all its other tasks. Passing a <a class="el" href="class_f_cam_1_1_shot.html" title="Shot collects parameters for capturing a frame.">Shot</a> object with a Discard image to a <a class="el" href="class_f_cam_1_1_sensor.html" title="A base class for image sensors.">Sensor</a> results in a <a class="el" href="class_f_cam_1_1_frame.html" title="Data returned by the sensor as a result of a shot.">Frame</a> with a non-valid <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a>, but all device actions are performed, and all <a class="el" href="class_f_cam_1_1_frame.html" title="Data returned by the sensor as a result of a shot.">Frame</a> metadata, such as histogram data or <a class="el" href="class_f_cam_1_1_device.html" title="An abstract base class for devices.">Device</a> tags, are valid. You can create a Discard image with: <code>Image(size, type, Image::Discard)</code> </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00111">111</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3211402f34df40097f0412dd343d1fcc"></a><!-- doxytag: member="FCam::Image::autoAllocate" ref="a3211402f34df40097f0412dd343d1fcc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FCam::Image::autoAllocate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this image is a special AutoAllocate image. </p>
<p>When passed as an argument to a function, an AutoAllocate image indicates that the function should create a new <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> to store the results in, based on the attributes of the <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> passed in. Passing a <a class="el" href="class_f_cam_1_1_shot.html" title="Shot collects parameters for capturing a frame.">Shot</a> object with an AutoAllocate image to a <a class="el" href="class_f_cam_1_1_sensor.html" title="A base class for image sensors.">Sensor</a> makes the <a class="el" href="class_f_cam_1_1_sensor.html" title="A base class for image sensors.">Sensor</a> allocate a new buffer for the captured image data, which is returned in the <a class="el" href="class_f_cam_1_1_frame.html" title="Data returned by the sensor as a result of a shot.">Frame</a>. This allows you to reuse the same <a class="el" href="class_f_cam_1_1_shot.html" title="Shot collects parameters for capturing a frame.">Shot</a> object for multiple capture requests (or a stream request) without getFrame() overwriting the data for an earlier <a class="el" href="class_f_cam_1_1_frame.html" title="Data returned by the sensor as a result of a shot.">Frame</a> image. You can create an AutoAllocate image with: <code>Image(size, type, Image::AutoAllocate)</code> </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00128">128</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3cf193eeb6fcb23dc51137a494f5b2da"></a><!-- doxytag: member="FCam::Image::copy" ref="a3cf193eeb6fcb23dc51137a494f5b2da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_cam_1_1_image.html">Image</a> FCam::Image::copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> containing a copy of the current Image's data. </p>
<p>Useful for converting an <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> with a weak reference to an <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> with a strong reference to its data. This requires a full copy of the underlying image data, so it can be quite slow for large images. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00245">245</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e80f78c2522d748e91952bc91ebd420"></a><!-- doxytag: member="FCam::Image::subImage" ref="a8e80f78c2522d748e91952bc91ebd420" args="(unsigned int x, unsigned int y, Size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_cam_1_1_image.html">Image</a> FCam::Image::subImage </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_cam_1_1_size.html">Size</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retuns an image that points to a section of the current image. </p>
<p>The subimage shares the same underlying buffer. The requested size will be trimmed if it would exceed the bounds of the current image. The arguments are the location of the top-left corner of the subImage and the size of the subImage. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00215">215</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab49efc2d6383c57fb67f34182f3e7afe"></a><!-- doxytag: member="FCam::Image::operator=" ref="ab49efc2d6383c57fb67f34182f3e7afe" args="(const Image &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp; FCam::Image::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Become a new reference to an existing image. </p>
<p>This never copies image data. It just produces a new reference to the same data, with the same properties. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00191">191</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef8822e9506f3419cf96862764588c85"></a><!-- doxytag: member="FCam::Image::operator()" ref="aef8822e9506f3419cf96862764588c85" args="(unsigned int x, unsigned int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* FCam::Image::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a pixel in the image. </p>
<p>Returns a pointer to the first byte of a pixel at image location <em></em>(x,y). The image is laid out in memory in row-major order. Each row is contigious, and there may be a gap between rows, with each row <em>y</em> of pixels starting at memory offset <code> y * <a class="el" href="class_f_cam_1_1_image.html#add66fb78d4a26c308e591d9b84912de8" title="The increment between two rows of the image in bytes.">bytesPerRow()</a> </code>. Each row itself is <code> <a class="el" href="class_f_cam_1_1_image.html#ac44569fe5a9f3843cf75b8b6edb07e80" title="The width of the image in pixels.">width()</a> * <a class="el" href="class_f_cam_1_1_image.html#a0173d44875d7c65967e600e6ee50b59f" title="The size of an image pixel in bytes.">bytesPerPixel()</a> </code> bytes long. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00242">242</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac01a574c3466aa4a0b93cdb8cacfee5d"></a><!-- doxytag: member="FCam::Image::copyFrom" ref="ac01a574c3466aa4a0b93cdb8cacfee5d" args="(const Image &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FCam::Image::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the image data from the source <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> into this <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a>. </p>
<p>Useful for transferring image blocks into pre-allocated (possibly weakly-referenced) buffers. Mismatched sizes are allowed. In case of a larger source image, only the section that fits into this image will be copied. In case of a smaller source image, the pixels in this <a class="el" href="class_f_cam_1_1_image.html" title="A reference-counted Image object.">Image</a> outside the source image's area are not modified. Ignores image types entirely. Actually copies image data, so can be quite slow. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00259">259</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78791c1f2da4e9ef0093cbf25c3b01e9"></a><!-- doxytag: member="FCam::Image::lock" ref="a78791c1f2da4e9ef0093cbf25c3b01e9" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FCam::Image::lock </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the image to prevent other threads writing to it with a configurable timeout in microseconds. </p>
<p>Returns whether the lock was acquired.</p>
<p>The default timeout (-1) indicates you should wait indefinitely, and should always return true. A timeout of zero will not block at all.</p>
<p>Images have locks to coordinate access between multiple threads. When new frames come in, the <a class="el" href="namespace_f_cam.html" title="Main namespace for the API.">FCam</a> API will try to lock the target image for them with a short timeout and copy the data in. If the image is still locked at the end of the timeout, it will instead drop the data on the floor (avoiding the expensive memcpy). You can use this for rate control of a viewfinder like so:</p>
<div class="fragment"><pre class="fragment">
         Shot viewfinder;
         ...
         viewfinder.image = Image(640, 480, UYUV);
         ...
         sensor.stream(viewfinder);
         while (1) {
             // Get the most recent viewfinder frame with image data
             Frame f;
             do {
                 f = sensor.getFrame();
                 // feed the frame to the autoexposure and autofocus routines
                 ...
             } while (sensor.framesPending() || !f.image().valid());
           
             f.image().lock();
             // Do something expensive with the image. 
             // No memcpys into the image will take place during this time.
             f.image().unlock();
         }        
         </pre></div><p>If you absolutely want to save every piece of image data, you should set the target image to an AutoAllocated one, Even the example above doesn't guarantee image data hasn't been clobbered just before you call <a class="el" href="class_f_cam_1_1_image.html#a78791c1f2da4e9ef0093cbf25c3b01e9" title="Lock the image to prevent other threads writing to it with a configurable timeout in microseconds...">lock()</a>. It only guarantees you get one consistent image and not a half-written one. If you spend all your CPU time with the frame locked, you may starve the <a class="el" href="namespace_f_cam.html" title="Main namespace for the API.">FCam</a> runtime of chances to give you new image data.</p>
<p>Your image may still get clobbered if other threads don't respect the lock, or if the image is a weak reference, and other independently created weak references to the same data exist are being used to write to it. Best to only have one image that refers to external data (images created by other libraries, framebuffers, etc), and construct other references to that data using copies of the first image. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00319">319</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98de7193d8d8c41c844f1576e6b1e703"></a><!-- doxytag: member="FCam::Image::unlock" ref="a98de7193d8d8c41c844f1576e6b1e703" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FCam::Image::unlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the image. </p>
<p>See <a class="el" href="class_f_cam_1_1_image.html#a78791c1f2da4e9ef0093cbf25c3b01e9">lock</a> for details. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00346">346</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb02eaaf88304c70258b0ce17a4915b6"></a><!-- doxytag: member="FCam::Image::operator==" ref="acb02eaaf88304c70258b0ce17a4915b6" args="(const Image &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FCam::Image::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_cam_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two images for equality. </p>
<p>Two images are equal if they view the same image data with the same attributes, so two offset subimages of a larger image won't be equal, and neither would two subimages of the same region, if one has a different type than the other. </p>

<p>Definition at line <a class="el" href="_image_8cpp_source.html#l00360">360</a> of file <a class="el" href="_image_8cpp_source.html">Image.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a5d22d34434fe7c747f902ce4e645f6ee"></a><!-- doxytag: member="FCam::Image::Discard" ref="a5d22d34434fe7c747f902ce4e645f6ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * <a class="el" href="class_f_cam_1_1_image.html#a5d22d34434fe7c747f902ce4e645f6ee">FCam::Image::Discard</a> = (unsigned char *)(0)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This value for data represents an image with no allocated memory that should never have data copied into it. </p>
<p>It is equal to NULL. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00138">138</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<a class="anchor" id="afb3e57a2a829d8cd8aeec326ca8e1c84"></a><!-- doxytag: member="FCam::Image::AutoAllocate" ref="afb3e57a2a829d8cd8aeec326ca8e1c84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * <a class="el" href="class_f_cam_1_1_image.html#afb3e57a2a829d8cd8aeec326ca8e1c84">FCam::Image::AutoAllocate</a> = (unsigned char *)(-1)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This value for data represents image data whose first user should allocate memory for. </p>
<p>If used as the image field of a <a class="el" href="class_f_cam_1_1_shot.html" title="Shot collects parameters for capturing a frame.">Shot</a>, it indicates that a new buffer should be allocated for every new frame. </p>

<p>Definition at line <a class="el" href="_image_8h_source.html#l00145">145</a> of file <a class="el" href="_image_8h_source.html">Image.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/FCam/<a class="el" href="_image_8h_source.html">Image.h</a></li>
<li>src/<a class="el" href="_image_8cpp_source.html">Image.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Nov 12 2010 15:26:14 for FCam by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
